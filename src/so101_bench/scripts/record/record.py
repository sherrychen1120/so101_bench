#!/usr/bin/env python
# 
# BASED ON lerobot/src/lerobot/record.py
# 
# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Records a dataset. Actions for the robot can be either generated by teleoperation or by a policy.

Example:

```shell
lerobot-record \
    --robot.type=so100_follower \
    --robot.port=/dev/tty.usbmodem58760431541 \
    --robot.cameras="{laptop: {type: opencv, camera_index: 0, width: 640, height: 480}}" \
    --robot.id=black \
    --dataset.repo_id=aliberts/record-test \
    --dataset.num_episodes=2 \
    --dataset.single_task="Grab the cube" \
    # <- Teleop optional if you want to teleoperate to record or in between episodes with a policy \
    # --teleop.type=so100_leader \
    # --teleop.port=/dev/tty.usbmodem58760431551 \
    # --teleop.id=blue \
    # <- Policy optional if you want to record with a policy \
    # --policy.path=${HF_USER}/my_policy \
    # <- Raw format optional for debugging and visualization \
    # --dataset.save_raw_format=true \
    # --dataset.raw_format_root=/path/to/raw/datasets \
    # --dataset.raw_format_videos=true \
```
"""

import logging
import time
from copy import deepcopy
from dataclasses import asdict
from pathlib import Path
from pprint import pformat

from lerobot.cameras import (  # noqa: F401
    CameraConfig,  # noqa: F401
)
from lerobot.cameras.opencv.configuration_opencv import OpenCVCameraConfig  # noqa: F401
from lerobot.cameras.realsense.configuration_realsense import RealSenseCameraConfig  # noqa: F401
from lerobot.configs import parser
from lerobot.configs.policies import PreTrainedConfig
from lerobot.datasets.image_writer import safe_stop_image_writer
from lerobot.datasets.lerobot_dataset import LeRobotDataset
from lerobot.datasets.utils import build_dataset_frame, hw_to_dataset_features
from lerobot.datasets.video_utils import VideoEncodingManager
from lerobot.policies.factory import make_policy
from lerobot.policies.pretrained import PreTrainedPolicy
from lerobot.robots import (  # noqa: F401
    Robot,
    RobotConfig,
    bi_so100_follower,
    hope_jr,
    koch_follower,
    make_robot_from_config,
    so100_follower,
    so101_follower,
)
from lerobot.teleoperators import (  # noqa: F401
    Teleoperator,
    TeleoperatorConfig,
    bi_so100_leader,
    homunculus,
    koch_leader,
    make_teleoperator_from_config,
    so100_leader,
    so101_leader,
)
from lerobot.teleoperators.keyboard.teleop_keyboard import KeyboardTeleop
from lerobot.utils.control_utils import (
    init_keyboard_listener,
    is_headless,
    predict_action,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
)
from lerobot.utils.robot_utils import busy_wait
from lerobot.utils.utils import (
    get_safe_torch_device,
    init_logging,
    log_say,
)
from lerobot.utils.visualization_utils import _init_rerun, log_rerun_data

from so101_bench.raw_dataset_recorder import RawDatasetRecorder
from so101_bench.task_configurator import TaskConfigurator
from so101_bench.recorder_configs import RecordConfig

@safe_stop_image_writer
def record_loop(
    robot: Robot,
    events: dict,
    fps: int,
    dataset: LeRobotDataset | None = None,
    raw_recorder: RawDatasetRecorder | None = None,
    teleop: Teleoperator | list[Teleoperator] | None = None,
    policy: PreTrainedPolicy | None = None,
    control_time_s: int | None = None,
    single_task: str | None = None,
    display_data: bool = False,
):
    if dataset is not None and dataset.fps != fps:
        raise ValueError(f"The dataset fps should be equal to requested fps ({dataset.fps} != {fps}).")

    teleop_arm = teleop_keyboard = None
    if isinstance(teleop, list):
        teleop_keyboard = next((t for t in teleop if isinstance(t, KeyboardTeleop)), None)
        teleop_arm = next(
            (
                t
                for t in teleop
                if isinstance(t, (so100_leader.SO100Leader, so101_leader.SO101Leader, koch_leader.KochLeader))
            ),
            None,
        )

        if not (teleop_arm and teleop_keyboard and len(teleop) == 2 and robot.name == "lekiwi_client"):
            raise ValueError(
                "For multi-teleop, the list must contain exactly one KeyboardTeleop and one arm teleoperator. Currently only supported for LeKiwi robot."
            )

    # if policy is given it needs cleaning up
    if policy is not None:
        policy.reset()

    actual_duration_s = 0
    sequence_number = 0
    start_episode_t = time.perf_counter()
    while actual_duration_s < control_time_s:
        sequence_number += 1
        start_loop_t = time.perf_counter()
        start_loop_timestamp = time.time()

        # Call this before any other operations to ensure the event is recorded.
        # Because events might lead to early exit of the loop.
        if raw_recorder is not None:
            raw_recorder.add_event(
                frame_timestamp=start_loop_timestamp,
                events=events,
            )

        if events["emergency_stop"]:
            logging.warning("Emergency stop pressed! Stopping data recording...")
            assert events["exit_early"]
            events["exit_early"] = False
            break

        if events["exit_early"]:
            events["exit_early"] = False
            break

        observation = robot.get_observation()

        if policy is not None or dataset is not None:
            observation_no_timestamp = {k: v for k, v in observation.items() if not k.endswith("_timestamp")}
            observation_frame = build_dataset_frame(dataset.features, observation_no_timestamp, prefix="observation")

        if policy is not None:
            action_values = predict_action(
                observation_frame,
                policy,
                get_safe_torch_device(policy.config.device),
                policy.config.use_amp,
                task=single_task,
                robot_type=robot.robot_type,
            )
            action = {key: action_values[i].item() for i, key in enumerate(robot.action_features)}
        elif policy is None and isinstance(teleop, Teleoperator):
            action = teleop.get_action()
        elif policy is None and isinstance(teleop, list):
            # TODO(pepijn, steven): clean the record loop for use of multiple robots (possibly with pipeline)
            arm_action = teleop_arm.get_action()
            arm_action = {f"arm_{k}": v for k, v in arm_action.items()}

            keyboard_action = teleop_keyboard.get_action()
            base_action = robot._from_keyboard_to_base_action(keyboard_action)

            action = {**arm_action, **base_action} if len(base_action) > 0 else arm_action
        else:
            logging.info(
                "No policy or teleoperator provided, skipping action generation."
                "This is likely to happen when resetting the environment without a teleop device."
                "The robot won't be at its rest position at the start of the next episode."
            )
            continue

        # Action can eventually be clipped using `max_relative_target`,
        # so action actually sent is saved in the dataset.
        sent_action = robot.send_action(action)

        if dataset is not None:
            sent_action_no_timestamp = {k: v for k, v in sent_action.items() if k != "action_timestamp"}
            action_frame = build_dataset_frame(dataset.features, sent_action_no_timestamp, prefix="action")
            frame = {**observation_frame, **action_frame}
            dataset.add_frame(frame, task=single_task)

        # Add frame to raw recorder if enabled
        # Use start_loop_timestamp as the frame timestamp as that's controlled to run
        # at as close to fps as possible.
        if raw_recorder is not None:
            raw_recorder.add_frame(
                observation=deepcopy(observation),
                action=sent_action,
                frame_timestamp=start_loop_timestamp,
                sequence_number=sequence_number,
            )

        if display_data:
            log_rerun_data(observation, action)

        dt_s = time.perf_counter() - start_loop_t
        busy_wait(1 / fps - dt_s)

        actual_duration_s = time.perf_counter() - start_episode_t


@parser.wrap()
def record(cfg: RecordConfig) -> LeRobotDataset:
    init_logging()
    logging.info(pformat(asdict(cfg)))
    if cfg.display_data:
        _init_rerun(session_name="recording")

    robot = make_robot_from_config(cfg.robot)
    teleop = make_teleoperator_from_config(cfg.teleop) if cfg.teleop is not None else None

    action_features = hw_to_dataset_features(robot.action_features, "action", cfg.dataset.video)
    obs_features = hw_to_dataset_features(robot.observation_features, "observation", cfg.dataset.video)
    dataset_features = {**action_features, **obs_features}

    # Initialize raw dataset recorder if enabled
    raw_recorder = None
    task_configurator = None
    if cfg.dataset.save_raw_format:
        raw_root = cfg.dataset.raw_format_root
        # Extract dataset name from repo_id (e.g., "user/dataset" -> "dataset")
        dataset_name = cfg.dataset.repo_id.split("/")[-1]
        dataset_task_config = None
        if cfg.dataset.tasks_dir is not None and cfg.dataset.task_name is not None:
            task_configurator = TaskConfigurator(
                tasks_dir=Path(cfg.dataset.tasks_dir),
                task_name=cfg.dataset.task_name,
            )
            dataset_task_config = task_configurator.generate_task_config_for_dataset()
        raw_recorder = RawDatasetRecorder(
            dataset_name=dataset_name,
            root_dir=raw_root,
            is_resume=cfg.resume,
            robot_config=asdict(cfg.robot),
            robot_calibration_fpath=robot.calibration_fpath,
            teleop_config=asdict(cfg.teleop),
            teleop_calibration_fpath=teleop.calibration_fpath,
            dataset_task_config=dataset_task_config,
            fps=cfg.dataset.fps,
            save_videos=cfg.dataset.raw_format_videos,
            image_writer_processes=cfg.dataset.num_image_writer_processes,
            image_writer_threads=cfg.dataset.num_image_writer_threads_per_camera,
        )
        
    if cfg.resume:
        dataset = LeRobotDataset(
            cfg.dataset.repo_id,
            root=cfg.dataset.root,
            batch_encoding_size=cfg.dataset.video_encoding_batch_size,
        )

        if hasattr(robot, "cameras") and len(robot.cameras) > 0:
            dataset.start_image_writer(
                num_processes=cfg.dataset.num_image_writer_processes,
                num_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            )
        sanity_check_dataset_robot_compatibility(dataset, robot, cfg.dataset.fps, dataset_features)
    else:
        # Create empty dataset or load existing saved episodes
        sanity_check_dataset_name(cfg.dataset.repo_id, cfg.policy)
        dataset = LeRobotDataset.create(
            cfg.dataset.repo_id,
            cfg.dataset.fps,
            root=cfg.dataset.root,
            robot_type=robot.name,
            features=dataset_features,
            use_videos=cfg.dataset.video,
            image_writer_processes=cfg.dataset.num_image_writer_processes,
            image_writer_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            batch_encoding_size=cfg.dataset.video_encoding_batch_size,
        )

    # Load pretrained policy
    policy = None if cfg.policy is None else make_policy(cfg.policy, ds_meta=dataset.meta)

    robot.connect()
    if teleop is not None:
        teleop.connect()
    
    # TODO(sherry): Factor out KeyboardEventListener to a separate class
    # that manages `events`` and controls the keyboard listener.
    events = {
        "stop_recording": False,
    }
    with VideoEncodingManager(dataset):
        recorded_episodes = 0
        while recorded_episodes < cfg.dataset.num_episodes and not events["stop_recording"]:
            log_say(f"Recording episode {dataset.num_episodes}", cfg.play_sounds)
            
            # Get task configuration if enabled
            task_config = None
            if task_configurator is not None:
                try:
                    task_config = task_configurator.get_task_config_from_user()
                except Exception as e:
                    logging.error(f"Error loading task configuration: {e}")
                    log_say(f"Error with task configuration: {e}", cfg.play_sounds)
                    # Continue without task config
                    task_config = None
            
            # Start raw recording episode if enabled
            if raw_recorder is not None:
                run_mode = "policy" if policy is not None else "teleop"
                policy_info = None
                if policy is not None:
                    policy_info = {
                        "policy_path": getattr(cfg.policy, "pretrained_path", None),
                        "policy_name": policy.__class__.__name__,
                    }
                
                raw_recorder.start_episode(
                    episode_idx=dataset.num_episodes,
                    run_mode=run_mode,
                    policy_info=policy_info,
                    leader_id=getattr(cfg.teleop, "id", None) if cfg.teleop else None,
                    follower_id=getattr(cfg.robot, "id", None),
                    task_config=task_config,
                )
            
            # Starting keyboard listener right before the record loop
            listener, events = init_keyboard_listener()
            
            record_loop(
                robot=robot,
                events=events,
                fps=cfg.dataset.fps,
                teleop=teleop,
                policy=policy,
                dataset=dataset,
                raw_recorder=raw_recorder,
                control_time_s=cfg.dataset.episode_time_s,
                single_task=cfg.dataset.single_task,
                display_data=cfg.display_data,
            )

            # Execute a few seconds without recording to give time to manually reset the environment
            # Skip reset for the last episode to be recorded
            if not events["stop_recording"] and (
                (recorded_episodes < cfg.dataset.num_episodes - 1) or events["rerecord_episode"]
            ):
                log_say("Reset the environment", cfg.play_sounds)
                record_loop(
                    robot=robot,
                    events=events,
                    fps=cfg.dataset.fps,
                    teleop=teleop,
                    control_time_s=cfg.dataset.reset_time_s,
                    single_task=cfg.dataset.single_task,
                    display_data=cfg.display_data,
                )

            if events["rerecord_episode"]:
                log_say("Re-record episode", cfg.play_sounds)
                events["rerecord_episode"] = False
                events["exit_early"] = False
                dataset.clear_episode_buffer()
                # Clear raw recorder episode if needed
                if raw_recorder is not None:
                    raw_recorder.reset_episode_data()
                continue

            # Stop keyboard listener at the end of each episode.
            if not is_headless() and listener is not None:
                listener.stop()

            dataset.save_episode()
            
            # Save raw episode if enabled
            if raw_recorder is not None:
                raw_recorder.save_episode(task_description=cfg.dataset.single_task)
            
            recorded_episodes += 1

    log_say("Stop recording", cfg.play_sounds, blocking=True)

    robot.disconnect()
    if teleop is not None:
        teleop.disconnect()

    if not is_headless() and listener is not None:
        listener.stop()

    if raw_recorder is not None:
        raw_recorder.cleanup()

    if cfg.dataset.push_to_hub:
        dataset.push_to_hub(tags=cfg.dataset.tags, private=cfg.dataset.private)

    log_say("Exiting", cfg.play_sounds)
    return dataset


def main():
    record()


if __name__ == "__main__":
    main()
